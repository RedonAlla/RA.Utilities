---
title: RA.Utilities.Feature.Extensions
sidebar_position: 5
---

```powershell
Namespace: RA.Utilities.Feature.Extensions
```

The primary purpose of this namespace is to provide a **fluent and discoverable API for registering your CQRS features**
(commands, queries, notifications, and their associated behaviors/validators) with the .NET dependency injection container.

It acts as the main entry point for wiring up the components of the `RA.Utilities.Feature` library.

## ðŸ”‘ Key Purpose and Design

The `FeatureBuilderExtensions` class uses the **Builder Pattern** to create a clean, readable, and chainable configuration experience.
Let's break down how it works:

#### 1. Bootstrapping the Feature:
The process starts with an extension method on `IServiceCollection`, such as `AddFeature` or `AddNotification`.

```csharp showLineNumbers
// From: /RA.Utilities/Application/RA.Utilities.Feature/Extensions/FeatureBuilderExtensions.cs

public static FeatureBuilder<TRequest, TResponse> AddFeature<TRequest, TResponse, THandler>(
    this IServiceCollection services)
    where TRequest : IRequest<TResponse>
    where THandler : class, IRequestHandler<TRequest, TResponse>
{
    // Step 1: It registers the core handler for the request.
    services.AddScoped<IRequestHandler<TRequest, TResponse>, THandler>();

    // Step 2: It returns a new builder object.
    return new FeatureBuilder<TRequest, TResponse>(services);
}
```

#### 2. Enabling Fluent Chaining:
The key is that these methods return a `FeatureBuilder` or `NotificationFeatureBuilder` object.
This builder object holds a reference to the `IServiceCollection` and provides its own methods for adding related components,
like validators or pipeline behaviors.

#### 3. Creating a Vertical Slice Configuration:
This design allows you to define an entire vertical slice in a single, coherent block of code

**example:**
```csharp showLineNumbers
_ = services
      .AddFeature<CreateProductCommand, CreateProductHandler>() // 1. Starts with the extension method
      .AddDecoration<LoggingBehavior<CreateProductCommand>>()   // 2. Chains a behavior from the returned builder
      .AddValidator<CreateProductCommandValidator>();           // 3. Chains a validator from the builder
```

<br />
<br />

import DocCardList from '@theme/DocCardList';

<DocCardList />