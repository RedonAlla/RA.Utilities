---
title: RA.Utilities.Feature
sidebar_position: 1
sidebar_class_name: nav_session ra_utilities_mediator
---

import LogoSvg from '../../../../Assets/Images/mediator.svg';

<p align="center">
<LogoSvg width={'15rem'} height={'15rem'} />
</p>

[![NuGet version](https://img.shields.io/nuget/v/RA.Utilities.Feature.svg?logo=nuget&label=NuGet)](https://www.nuget.org/packages/RA.Utilities.Feature/)
[![NuGet Downloads](https://img.shields.io/nuget/dt/RA.Utilities.Feature.svg?logo=nuget)](https://www.nuget.org/packages/RA.Utilities.Feature/)
[![Codecov](https://codecov.io/github/RedonAlla/RA.Utilities/graph/badge.svg)](https://codecov.io/github/RedonAlla/RA.Utilities)
[[![Publish NuGet](https://github.com/RedonAlla/RA.Utilities/actions/workflows/publish-nuget.yml/badge.svg)](https://github.com/RedonAlla/RA.Utilities/actions/runs/19650635405)
[![GitHub license](https://img.shields.io/github/license/RedonAlla/RA.Utilities)](https://github.com/RedonAlla/RA.Utilities/blob/main/LICENSE)

The main goal of this package is to help you organize your application's business logic into self-contained "features" or "slices."
Instead of having logic for a single operation scattered across multiple layers (e.g., a controller, a service, a repository), all the code for one use case‚Äîfrom the incoming request to the final response‚Äîis located together.

This solves a common problem with traditional layered architectures where classes can become bloated and tightly coupled, making the codebase difficult to navigate and maintain.

## ‚ú® Key Features and How They Help
The package provides several key components to achieve this clean architecture:

1. **Base Handlers ([`IRequestHandler<TRequest, TResponse>`](./Abstractions/IRequestHandler.md))**:

  * **Purpose*: These are base classes for your CQRS command and query handlers.
  * **Benefit**: They reduce boilerplate code by providing built-in logging for the start and end of a request, as well as automatic exception handling.
  Any unhandled exception within your logic is safely caught and wrapped in a Result.Failure object, preventing crashes and ensuring a consistent error-handling strategy.

2. **Validation Pipeline Behavior ([`ValidationBehavior<TRequest, TResponse>`](./Behaviors/ValidationBehavior.md))**:

  * **Purpose**: This is a pipeline behavior (like MediatR middleware) that automatically validates incoming commands and queries before they reach your business logic.
  * **Benefit**: It uses [`FluentValidation`](https://docs.fluentvalidation.net/en/latest/) to check the request.
  If validation fails, it immediately stops processing and returns a structured validation error.
  This ensures that your handlers only ever deal with valid data, making them simpler and more robust.

3. **Seamless Integration with RA.Utilities.Core**:

  * **Purpose**: The handlers are designed to return a [`Result<T>`](../../core/RA.Utilities.Core/Results.md) object from the [`RA.Utilities.Core`](../../core/RA.Utilities.Core/index.mdx) package.
  * **Benefit**: This allows you to explicitly communicate the outcome of an operation‚Äîeither success with a value or a predictable failure (like "user not found" or "item already exists")‚Äîwithout using exceptions for control flow.
  This leads to cleaner, more readable, and more predictable code.

## üåü Benefits

The package has been fully rewritten to avoid reflection, 
it uses strongly-typed generic registration and explicit DI resolution instead of dynamic type lookups or assembly scanning.

  * ‚úÖ No runtime reflection
  * ‚úÖ Purely generic and compile-time safe
  * ‚úÖ Simplified DI registration via [`AddRequestHandler<TRequest, TResponse, THandler>()`](./Extensions/MediatorServiceCollectionExtensions.md)
  * ‚úÖ The mediator now supports notifications and publish/subscribe just like MediatR.
  * ‚úÖ Multiple notifications (publish/subscribe model)
  * ‚úÖ Multiple notification pipeline behaviors (logging, metrics, retry, etc.)
  * ‚úÖ Fluent builder style consistent with the request builder


## üîß Design Overview

1. **`IFeatureBuilder`** ‚Üí Fluent builder interface
2. **`FeatureBuilder<TRequest, TResponse>`** and **`FeatureBuilder<TRequest>`** ‚Üí Concrete builders for both request types
3. Extension methods:
  * `AddFeature<TRequest, TResponse, THandler>()`
  * `AddFeature<TRequest, THandler>()`
4. Each builder:
  * Registers the handler.
  * Supports `.AddDecoration<TBehavior>()` ‚Üí registers a pipeline behavior.
  * Supports `.AddValidator<TValidator>()` ‚Üí registers validation pipeline.

## üõ†Ô∏è Installation

You can install the package via the .NET CLI:

```bash
dotnet add package RA.Utilities.Feature
```

Or through the NuGet Package Manager console:

```powershell
Install-Package RA.Utilities.Feature
```

## üîó Dependencies

-  [`RA.Utilities.Core.Exceptions`](../../core/RA.Utilities.Core.Exceptions/index.mdx)
-  [`RA.Utilities.Core`](../../core/RA.Utilities.Core/index.mdx)
-  [`FluentValidation`](https://docs.fluentvalidation.net/en/latest/)
-  [`Microsoft.Extensions.DependencyInjection.Abstractions`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection)
-  [`Microsoft.Extensions.Logging.Abstractions`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.abstractions)


<br />
<br />

import DocCardList from '@theme/DocCardList';

<DocCardList />